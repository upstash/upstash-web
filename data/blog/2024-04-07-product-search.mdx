---
title: "Integrating Vector Search in E-commerce Platforms with Upstash Vector"
slug: integrating-vector-search-in-e-commerce-platforms-with-upstash-vector
authors:
  - rishi
tags: [vector, rag, upstash, astro]
---

In this step-by-step guide, I talk about how I built a Tweet Scheduler using Upstash QStash, Upstash Redis, Next.js Server Actions and Vercel. Scheduling Twitter posts helps you maintain a consistent presence, engage with your audience at optimal times, and efficiently manage your content strategy.

## Prerequisites

You will need the following:

- [Node.js 18](https://nodejs.org/en/blog/announcements/v18-release-announce) or later
- An [Upstash](https://upstash.com) account

## Tech Stack

Following technologies are used in this guide:

| Technology | Description |
| --- | --- |
| [Upstash](https://upstash.com) | Serverless database platform. You're going to use Upstash Vector for storing vector embeddings and metadata. |
| [FastAPI](https://fastapi.tiangolo.com) | A high performance framework to build APIs with Python 3.8+. |
| [Astro](https://astro.build) | Framework for building fast, modern websites with serverless backend support. |
| [TailwindCSS](https://tailwindcss.com) | CSS framework for building custom designs. |

## Table Of Contents

- [Create an Upstash Vector Index](#create-an-upstash-vector-index)
- [Create a new FastAPI application](#create-a-new-fastapi-application)
- [Generate Text Embeddings using CLIPTextModel](#generate-text-embeddings-using-cliptextmodel)
- [Generate Image Embeddings using CLIPModel](#generate-image-embeddings-using-clipmodel)
- [Dynamically update Upstash Vector Index with new products](#dynamically-update-upstash-vector-index-with-new-products)
- [Dynamically search from Upstash Vector Index for similar products](#dynamically-search-from-upstash-vector-index-for-similar-products)
- [Create a new Astro application](#create-a-new-astro-application)

## Create an Upstash Vector Index

Once you have created an Upstash account and are logged in, go to the Vector tab and click on **Create Index** to start creating a vector index.

![Create an Upstash Vector](/blog/integrating-vector-search-in-e-commerce-platforms-with-upstash-vector/vector-tab.png)

Enter the index name of your choice (say, `article`) and set the vector dimensions to be of 1536.

![Create An Upstash Vector Index](/blog/integrating-vector-search-in-e-commerce-platforms-with-upstash-vector/vector-create.png)

Now, scroll down till the **Connect** section, and click the **.env** button. Copy the contents, and save it somewhere safe to be used further in your application.

![Vector Index Environment Variables](/blog/integrating-vector-search-in-e-commerce-platforms-with-upstash-vector/index.png)

## Create a new FastAPI application

Let’s get started by creating a new FastAPI project. Open your terminal and run the following commands:

```bash
# Create and move to the new directory
mkdir ecommerce-vector-search-server
cd ecommerce-vector-search-server

# Create a main.py file
touch main.py
```

The commands above create a directory named `ecommerce-vector-search-server` with `main.py` file in it.

Once you have cloned the repo, create an .env file. You are going to add the secret keys obtained in the sections above.

The .env file should contain the following keys:

```bash
# .env
 
# Upstash Vector Keys
UPSTASH_VECTOR_REST_URL="https://...-us1-vector.upstash.io"
UPSTASH_VECTOR_REST_TOKEN="...="
```

Next, in your first terminal window, run the command below to install the necessary libraries for building the application:

```bash
pip install fastapi "uvicorn[standard]"
pip install upstash_vector
pip install python_dotenv torch pillow transformers numpy
```

The above command installs the following packages:

- FastAPI
- Uvicorn
- Upstash Python Module
- python_dotenv
- PyTorch
- Pillow
- Numpy
- Transformers

TODO

## Generate Text Embeddings using CLIPTextModel

TODO

```python
import torch
from torchvision import transforms
from transformers import CLIPProcessor, CLIPTextModel

# Initialize the CLIP processor
processor = CLIPProcessor.from_pretrained("openai/clip-vit-base-patch32")

# Initialize the CLIPTextModel
text_model = CLIPTextModel.from_pretrained("openai/clip-vit-base-patch32")

# Function to generate vector embeddings from text
def getTextEmbeddings(text):
    pooled_output = []
    inputs = processor(text, return_tensors="pt", padding=True)
    with torch.no_grad():
        text_features = text_model(**inputs)
        pooled_output = text_features.pooler_output
    return pooled_output[0]
```

TODO

TODO

## Generate Image Embeddings using CLIPModel

TODO

```python
import torch
import requests
from PIL import Image
from torchvision import transforms
from transformers import CLIPProcessor, CLIPModel, CLIPTextModel

# Initialize the CLIPModel
image_model = CLIPModel.from_pretrained("openai/clip-vit-base-patch32")

# Image preprocesser
preprocess = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
])

# Function to fetch remote image
def getImage(url):
    res = requests.get(url, stream=True)
    return Image.open(res.raw)
 
# Function to generate vector embeddings from images
def getImageEmbeddings(image):
    image = preprocess(image)
    image = image.unsqueeze(0)
    with torch.no_grad():
        features = image_model.get_image_features(pixel_values=image)
    embedding = features.squeeze().cpu().numpy()
    return embedding.astype(np.float32)
```

TODO

## Dynamically update Upstash Vector Index with new products

TODO

```python
@app.post("/api/add")
async def add(request: Request):
    # Load JSON data from the request body
    request_body = await request.json()
    products = request_body['products']
    # Loop over each product
    for product in products:
        embedding = []
        # If the product has an image field
        if product["image"]:
            # Generate vector embeddings of the image of the product
            image = getImage(product["image"])
            embedding = getImageEmbeddings(image)
            # Insert the vector embeddings along with metadata into Upstash Vector
            index.upsert(vectors = [(random.random(), embedding.tolist(), product)])
        if product["title"]:
            # Generate vector embeddings of the title of the product
            text = product["title"]
            embedding = getTextEmbeddings(text)
            # Insert the vector embeddings along with metadata into Upstash Vector
            index.upsert(vectors = [(random.random(), embedding.tolist(), product)])
        if product["description"]:
            # Generate vector embeddings of the description of the product
            description = product["description"]
            embedding = getTextEmbeddings(description)
            # Insert the vector embeddings along with metadata into Upstash Vector
            index.upsert(vectors = [(random.random(), embedding.tolist(), product)])
```

TODO

TODO

## Dynamically search from Upstash Vector Index for similar products

TODO

```python
@app.post("/api/chat")
async def chat(request: Request):
    # Load JSON data from the request body
    request_body = await request.json()
    messages = request_body['messages']
    # Get the latest user message
    user_input = messages[-1]['content']
    query_embedding = []
    # If image URL was passed in the latest user query and get it's vector embeddings
    if "https://" in user_input:
        query_embedding = getImageEmbeddings(getImage(user_input))
    # Else assume text and get it's vector embeddings
    else:
        query_embedding = getTextEmbeddings(user_input)
    # Return the top 3 relevant vectors along with their metadata
    output = index.query(vector=query_embedding.tolist(),  top_k=3, include_metadata=True)
    return [item for item in output if item.score > 0.8]
```

TODO

## Create a new Astro application

Let’s get started by creating a new Astro project. Open your terminal and run the following command:

```bash
npm create astro@latest ecommerce-vector-search-ui
```

`npm create astro` is the recommended way to scaffold an Astro project quickly.

When prompted, choose the following:

- `Empty` when prompted on how to start the new project.
- `Yes` when prompted whether to write Typescript.
- `Strict` when prompted how strict Typescript should be.
- `Yes` when prompted to whether install dependencies.
- `Yes` when prompted to whether initialize a git repository.

Once that’s done, you can move into the project directory and start the app:

```bash
cd ecommerce-vector-search-ui
npm run dev
```

The app should be running on [localhost:4321](http://localhost:4321/). Let's close the development server as we move on to integrate TailwindCSS into the application.

### Add Tailwind CSS to the application

For styling the app, you will be using Tailwind CSS. Install and set up Tailwind CSS at the root of our project's directory by running:

```bash
npx astro add tailwind
```

When prompted, choose:

- `Yes` when prompted to install the Tailwind dependencies.
- `Yes` when prompted to generate a minimal `tailwind.config.mjs` file.
- `Yes` when prompted to make changes to Astro configuration file.

With choices as above, the command finishes integrating TailwindCSS into your Astro project. It installed the following dependency:

- `tailwindcss`: TailwindCSS as a package to scan your project files to generate corresponding styles.
- `@astrojs/tailwind`: The adapter that brings Tailwind's utility CSS classes to every `.astro` file and framework component in your project.

To create reactive interfaces quickly, let’s move onto integrating React in your Astro application.

### Integrate React in your Astro project

To prototype the reactive user interface quickly, you are gonna use React as the library with Astro. In your terminal window, execute the following command:

```bash
npx astro add react
```

`npx` allows us to execute npm packages binaries without having to first install it globally.

When prompted, choose the following:

- `Yes` when prompted whether to install the React dependencies.
- `Yes` when prompted whether to make changes to Astro configuration file.
- `Yes` when prompted whether to make changes to `tsconfig.json` file.

To create conversation user interface with product recommendations easily in React, let’s move on to installing an AI SDK in your Astro application.

### Install Vercel AI SDK

In your terminal window, run the command below to install the necessary library for building the conversation user interface:

```bash
npm install ai
```

The above command installs the following:

- `ai` library to build AI-powered streaming text and chat UIs.

### Build Chat (with Product Recommendations) User Interface

TODO

### Test the Astro Application (Locally)

Execute the following command in another terminal window to build and preview your Astro application:

```bash
npm run build && npm run preview
```

The app should be running on [localhost:4321](http://localhost:4321/).

> That was a lot of learning! You’re all done now ✨

## More Information

For more detailed insights, explore the references cited in this post.

- [GitHub Repo](https://github.com/rishi-raj-jain/schedule-qstash-queue-upstash)
- [Twitter OAuth 2.0 Flow](https://developer.twitter.com/en/docs/authentication/oauth-2-0/authorization-code)
- [Generating Twitter App Tokens](https://developer.twitter.com/en/docs/authentication/oauth-2-0/bearer-tokens)
- [React Form Hooks](https://react.dev/reference/react-dom/hooks)
- [Next.js Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)

## Conclusion

In this guide, you learned how to build a robust Tweet Scheduler leveraging Upstash's powerful Redis database and QStash queue. Upstash's scalability ensures reliable storage and scheduling of tweets combined with seamless deployment on Vercel create a fully automated system.
