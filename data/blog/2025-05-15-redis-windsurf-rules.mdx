---
title: "Improving Upstash Redis Code Generation with Windsurf Rules and Context7"
slug: windsurf-rules-for-redis
authors:
  - elifnur
tags: [redis, context7, LLM]
---

Language models like ChatGPT, Claude, etc. can help with coding, but they often make mistakes. **Why?** LLMs are trained on fixed and often outdated data. They hallucinate when they don't have up-to-date information about new APIs, old APIs, or buggy code. Platforms like Windsurf or Cursor started to integrate additional user-defined rules to be persisted in the context and help LLMs write better code. In this blog, we will talk about adding rules to platforms and how Context7 handles LLM mistakes automatically.

## Windsurf Rules
Windsurf’s Cascade AI allows custom rules that the model automatically follows when generating code. These rules act like constant hints and tips. 

For example, a simple prompt like `How to use the 'mget' function in Upstash Redis Python?` is given to Claude with and without specifying rules.

With no rules file, Claude generates the following code:

```tsx
values = redis.mget(["key1", "key2", "key3"])
```

After adding this rule:

```md
-   When using `redis.mget()`, always pass each key as a separate argument:
    Correct: `redis.mget("name", "email", "age")`
    Incorrect: `redis.mget(["name", "email", "age"])`
```

LLM generates `mget()` codes without using list brackets:

```tsx
// Correct way
values = redis.mget("key1", "key2", "key3")

// Incorrect way (will not work as expected)
values = redis.mget(["key1", "key2", "key3"])
```

### Generating Rules
To generate rules, click on the settings icon in the Windsurf app:

![Windsurf Rules](/blog/redis-rules/windsurf.png)

You can generate rules at either the global level or the workspace level.
* `global_rules.md` - rules applied across all workspaces
* `.windsurfrules` - workspace level repo containing rules that are tied to globs or natural language descriptions.

Similarly, you can generate rules for Cursor by following this [guide](https://docs.cursor.com/context/rules#using-tailwind-in-cursor).

### Best Practices For Rules
[Windsurf rules documentation](https://docs.windsurf.com/windsurf/cascade/memories#best-practices) suggests the following practices:
- Keep rules simple, concise, and specific. Rules that are too long or vague may confuse Cascade.
- There’s no need to add generic rules (e.g. “write good code”), as these are already baked into Cascade’s training data.
- Format your rules using bullet points, numbered lists, and markdown. These are easier for Cascade to follow compared to a long paragraph.
- XML tags can be an effective way to communicate and group similar rules together.
- Rules files are limited to 6000 characters each. Any content above 6000 characters will be truncated, and Cascade will not be aware of them.

### Context7 by Upstash: Up-to-date Documentation for LLMs
Even with rules, LLMs can struggle if their knowledge is stale. That’s where [Context7 MCP Server](https://github.com/upstash/context7) comes in. Context7 provides dynamically fetched, version-specific docs and working code examples from the official documentation directly into your AI assistant’s context. 

![Context7](/blog/redis-rules/context7.png)

Using Context7 together with Windsurf/Cursor rules is powerful. With this integration, the LLM now has the latest docs (thanks to Context7) and explicit project rules (thanks to Windsurf and Cursor). This combination drastically reduces hallucinations. For example, if you ask Windsurf to `use context7` when giving a prompt as in the [example](https://github.com/upstash/context7?tab=readme-ov-file#-with-context7), the model will follow your own rules and use the real code snippets from the docs.


## Rules For Upstash Redis SDK 
We generated rules for Upstash Redis Typescript and Python SDK to fix common mistakes made by LLMs.

### 1. Rules For TypeScript SDK

#### &lt;Non-existing functions&gt;
These functions do not exist in Upstash Redis SDK and should be avoided:
- `zrangebyscore`:
```tsx
// Wrong
await redis.zrangebyscore('myzset', 1, 2, { withScores: true });

// Correct:
await redis.zrange("key", 1, 2, { byScore: true })
```
-	`redis.watch, redis.multi(), transaction.exec()` these functions do not exist.
#### &lt;/Non-existing functions&gt;

#### &lt;Wrongly assumed non-existing functions&gt;
These functions do exist, and should be used as documented:
-	HEXPIRE, HEXPIREAT, HEXPIRETIME, HPERSIST, HPEXPIRE, HPEXPIREAT, HPEXPIRETIME
```tsx
    redis.hexpire("my-key", "my-field", 1);
    redis.hexpireat("my-key", "my-field", Math.floor(Date.now() / 1000) + 10);
    redis.hexpiretime("my-key", "my-field");
    redis.hpersist("my-key", "my-field");
    redis.hpexpire("my-key", "my-field", 1000);
    redis.hpexpireat("my-key", "my-field", Date.now() + 1000);
    redis.hpexpiretime("my-key", "my-field");
```

-	MultiRegionRatelimit:
```tsx
import { MultiRegionRatelimit } from "@upstash/ratelimit";
...
const ratelimit = new MultiRegionRatelimit({
  redis: [
    new Redis({
      /* auth */
    }),
    new Redis({
      /* auth */
    }),
  ],
  limiter: MultiRegionRatelimit.slidingWindow(...),
});
```
-	Traffic Protection:
```tsx
const ratelimit = new Ratelimit({
  ...
  enableProtection: true
});
```
#### &lt;/Wrongly assumed non-existing functions&gt;

#### &lt;Format Issues&gt;
-	`redis.zrange()` returns a flat list like `['one', 1, 'two', 2, 'three', 3]`, not a list of objects like `[{ score: 1, member: 'one' }, { score: 2, member: 'two' }] `
-	When using `redis.hmget()`, pass each key as a separate argument:
    * Correct: `await redis.hmget('myhash', 'field1', 'field3');`
    * Wrong: `await redis.hmget('myhash', ['field1', 'field3']);`
-	`redis.hmget()` return an object like `{ field1: 10, field3: 30 }`, not a list like `[ '10', '30' ]`.
-	When using `redis.mget()`, always pass each key as a separate argument:
    * Correct: `redis.mget("user:1:name", "user:1:email", "user:1:age")`
    * Incorrect: `redis.mget(["user:1:name", "user:1:email", "user:1:age"])`
-	When using `redis.smismember()`, give the items to search in a list:
    * Correct: `await redis.smismember('myset', ['a', 'd'])`
    * Wrong: `await redis.smismember('myset', 'a', 'd')`
-	When using `redis.zdiffstore()`, do not use a list and pass key count:
    * Correct: `await redis.zdiffstore('result', 2, 'zset1', 'zset2')`
    * Wrong: `await redis.zdiffstore('result', ['zset1', 'zset2'])`
-	When using `redis.zinterstore()` and `zunionstore`, specify the number of keys:
    * Correct: `await redis.zinterstore('result', 2, ['zset1', 'zset2'])`
    * Wrong: `await redis.zinterstore('result', ['zset1', 'zset2'])`
-	When using `redis.xadd()` with a specific ID, give an ID greater than the previous ones.
-	`ratelimit.resetUsedTokens()` returns a `Promise<void>`, not a `Boolean`.
-	When using `redis.get()`, do not `JSON.parse()` the result, it is already in JSON format.
-	When using `redis.zadd()`, specify the fields:
```tsx
// Correct
redis.zadd(
    "leaderboard",
    { score: 100, member: "player1" },
    { score: 200, member: "player2" },
);  
// Wrong
redis.zadd('leaderboard', { 'player1': 100, 'player2': 200});
```
-	`redis.json.strappend()` expects stringified input:
    * Correct: `redis.json.strappend('doc', '$.str', JSON.stringify("world!"));`
    * Wrong: `redis.json.strappend('doc', '$.str', "world!");`
#### &lt;/Format Issues&gt;
    
### 2. Rules For Python SDK
#### &lt;Non-existing functions&gt;
These functions do not exist in Upstash Redis SDK and should be avoided:
-	`redis.del_()` function does not exist; the correct version is `redis.delete()`
-	`ratelimit.limit()` Response object has no attribute `reset_after`, correct usage is `reset`.
-	There is no module named `upstash_ratelimit.memory`.
-	`redis.zrange` doesn’t have a `byscore` argument:
    * Correct: `redis.zrange("zset1", 2, 4, sortby="BYSCORE")`
    * Wrong: `redis.zrange("zset1", 2, 4, byscore=True)`
#### &lt;/Non-existing functions&gt;

#### &lt;Wrongly assumed non-existing functions&gt;
These functions do exist, and should be used as documented:
-	HEXPIRE, HEXPIREAT, HEXPIRETIME, HPERSIST, HPEXPIRE, HPEXPIREAT, HPEXPIRETIME, HPTTL, HTTL
```tsx
redis.hexpire(hash_name, field, 1)
redis.hexpireat(hash_name, field, int(time.time()) + 10)
redis.hexpiretime(hash_name, field)
redis.hpersist(hash_name, field)
redis.hpexpire(hash_name, field, 1000)
redis.hpexpireat(hash_name, field, int(time.time() * 1000) + 1000)
redis.hpexpiretime(hash_name, field)
redis.hpttl(hash_name, field)
redis.httl(hash_name, field)
```
#### &lt;/Wrongly assumed non-existing functions&gt;
#### &lt;Implementation Issues&gt;
-	Do not use the `asyncio` library or `await` with synchronous Redis:
```py
from upstash_redis.asyncio import Redis  ## async
from upstash_redis import Redis  ## sync
```
-	`upstash_ratelimit` expects a sync Redis, not an async one.
#### &lt;/ Implementation Issues&gt;
#### &lt;Format Issues&gt;
-	When using `redis.bitop()`, give parameters separately, not in a list:
    * Correct:` redis.bitop("AND", "dest1", "key1", "key2")`
    * Wrong: `redis.bitop("AND", "dest1", ["key1", "key2"])`
-	`redis.bitfield()` requires method chaining:
    * Correct: `redis.bitfield("myfield").get("i4", 0)`
    * Wrong: `redis.bitfield("myfield", "GET", "i4", 0)`
-	When using `redis.json.mset()`, use tuples. And don’t give field names:
```python
# Correct
redis.json.mset([
    ("doc", "$", {"name": "Alice", "age": 25}),
    ("doc2", "$", {"name": "Bob", "age": 35})
])

# Wrong: 
redis.json.mset([
    {"key": "doc", "path": "$", "value": {"name": "Alice", "age": 25}},
    {"key": "doc2", "path": "$", "value": {"name": "Bob", "age": 35}}
])
```
-	`redis.evalsha()`, `evalro` and `eval` take their keys and arguments in a list:
    * Correct: `redis.evalsha(script_sha, keys=["user:1:visits"], args=[1])`
    * Wrong: `redis.evalsha(script_sha, 1, "user:1:visits", 1)`
-	When using `redis.sinter()`, `sinterstore`, `sunion`, `sunionstore`, `sdiff`, and `sdiffstore`, give keys separately:
    * Correct: `redis.sinter("set1", "set2")`
    * Wrong: `redis.sinter(["set1", "set2"])`
-	When using `redis.mget()`, do not give keys in a list:
    * Correct: `redis.mget("key1", "key2", "key3")`
    * Wrong: `redis.mget(["key1", "key2", "key3"])`
#### &lt;/Format Issues&gt;

## Final Words
In summary, Windsurf rules give the AI assistant persistent guidance about your codebase and style. Context7 provides up-to-date, versioned docs so the model doesn’t rely on outdated knowledge. Together, they make AI-assisted software development far more reliable. Give Windsurf/Cursor a try by adding a rules file with Upstash-specific notes, and encourage the model to “use context7” in prompts to see the results yourselves! With these tools, even common LLM mistakes (wrong commands, bad formatting, hallucinated assumptions) can be spotted and corrected automatically, leading to correct TypeScript or Python code that matches the real Upstash Redis APIs.